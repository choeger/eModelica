// A = ["b"] C transforms to A = C, so the "b" must be put into its own NonTerminal
// => A = [B] C
// => B = "b"

// Stored Definition Within
Stored_Definition = [Within_Statement] Class_Definition_Statement*;
Within_Statement = "within" [Name] ";";

// Class Definition
Class_Definition_Statement = [Final] Class_Definition ";";
Final = "final";

Class_Definition = [Encapsulated] [Partial] Class_Def_KW Specifier;
Encapsulated = "encapsulated";
Partial = "partial";
Class_Def_KW = ClassDefSingleKW | ClassDefCombinedKW;
ClassDefSingleKW = "class" | "model" | "record" | "block" | "connector" | "type" | "package" | "function";
ClassDefCombinedKW = "expandable" "connector";

Specifier = Comp_Spec | Type_Spec | Enum_Spec | Der_Spec | Extend_Spec;
Comp_Spec = Identifier [String_Comment] Composition "end" Identifier;
Type_Spec = Identifier "=" Type_Prefix Name [Array_Subscripts] [Class_Modification] [String_Comment] [Annotation];
Enum_Spec = Identifier "=" "enumeration" "(" Enum_Spec_Part ")" [String_Comment] [Annotation];
Enum_Spec_Part = Enum_List | Enum_Spec_Colon;
Enum_List = Enumeration_Literal*^",";
Enum_Spec_Colon = ":";
Der_Spec = Identifier "=" "der" "(" Name "," Identifier+^"," ")" [String_Comment] [Annotation];
Extend_Spec = "extends" Identifier [Class_Modification] [String_Comment] Composition "end" Identifier;

Enumeration_Literal = Identifier [String_Comment] [Annotation];

Composition = Element_* Composition_Element* [External_Comp_Element];
//flaw in the specs: in MSL they seem to use [Annotation_Part] [Annotation] ";" in spec: [Annotation_Part] [Annotation_Part]
External_Comp_Element = "external" [Language_Specification] [External_Function_Call] [Annotation] ";" [Annotation_Part];
Composition_Element = Public_Elements | Protected_Elements | Equation_Section | Algorithm_Section;
Public_Elements = "public" Element_*;
Protected_Elements = "protected" Element_*;

Element_ = Element_Part | Annotation_Part;
Element_Part = Element ";";
Annotation_Part = Annotation ";";

Language_Specification = "STRING";

//adding trailing ";" - does not exist in spec, but in Standard Library...
External_Function_Call = [FunctionCallReference] Identifier "(" [Expression_List] ")";
FunctionCallReference = FunctionCallReferencePart+^"." "=";
FunctionCallReferencePart = Identifier [Array_Subscripts];

Element = Import_Clause | Extends_Clause | Component_Part;
Component_Part = [Redeclare] [Final] [Inner] [Outer] Component;
Redeclare = "redeclare";
Inner = "inner";
Outer = "outer";
Component = [Replaceable] ClassDefinitionOrMultipleComponentClause [Constraining_Clause_With_Comment];
//again we have a bogus here in the specification, we assume Constraining Clause can follow both
Replaceable = "replaceable";
Constraining_Clause_With_Comment = Constraining_Clause [String_Comment] [Annotation];
ClassDefinitionOrMultipleComponentClause = Class_Definition | MultipleComponentClause;

Import_Clause = RenamingImport | NamedImport;
RenamingImport = "import" Identifier "=" Name;
NamedImport = "import" Name [AllElementExt];
AllElementExt = ".*";

// extends
Extends_Clause = "extends" Name [Class_Modification] [Annotation];
Constraining_Clause = "constrainedby" Name [Class_Modification];

// component clause
MultipleComponentClause = Type_Prefix Name [Array_Subscripts] Component_List;
Type_Prefix = [Flow] [Kind] [InputOrOutput];
Flow = "flow";
Kind = "discrete" | "parameter" | "constant";
InputOrOutput = "input" | "output";

Component_List = Component_Declaration+^",";

Component_Declaration = Declaration [Conditional_Attribute] [String_Comment] [Annotation];

Conditional_Attribute = "if" Expression;

Declaration = Identifier [Array_Subscripts] [Modification];

// Modification
Modification = ModClassModification | ModAssExpression | ModBindExpression;
ModClassModification = Class_Modification [ModBindExpression];
ModAssExpression = ":=" Expression;
ModBindExpression = "=" Expression;

Class_Modification = "(" ModArgumentList ")";

ModArgumentList = ModArgument*^",";

ModArgument = Element_Modification | Element_Replaceable | Element_Redeclaration;

Element_Redeclaration = "redeclare" [Each] [Final] Element_Redeclaration_Suffix;
Each = "each";
Element_Redeclaration_Suffix = ClassDefinitionOrSingleComponentClause | Element_Replaceable;

// in the specification we do not see String_Comment optional here, seems to be a bug
Element_Modification = [Each] [Final] Component_Reference [Modification] [String_Comment];

Element_Replaceable = "replaceable" ClassDefinitionOrSingleComponentClause [Constraining_Clause];

ClassDefinitionOrSingleComponentClause = Class_Definition | SingleComponentClause;

SingleComponentClause = Type_Prefix Name SingleComponentDeclaration;

SingleComponentDeclaration = Declaration [String_Comment] [Annotation];

// Equations
Equation_Section = [Initial] "equation" EquationSectionElement*; 
EquationSectionElement = EquationPart | Annotation_Part;
EquationPart = Equation ";";

Algorithm_Section = [Initial] "algorithm" AlgorithmSectionElement*; 
AlgorithmSectionElement = StatementPart | Annotation_Part;
StatementPart = Statement ";";

Initial = "initial";

Equation = EquationContent [String_Comment] [Annotation];
EquationContent = BindExpression | If_Equation | For_Equation | Connect_Clause | When_Equation;
//TODO: here we must distinguish between BindExpression and IDENT Function_Call_Args!
BindExpression = Simple_Expression [EquationRhs];
EquationRhs = "=" Expression;
//IdentEquation = Identifier Function_Call_Args;

Statement = StatementContent [String_Comment] [Annotation];
StatementContent = ReferenceStatement | MultipleAssignment | If_Statement | For_Statement | While_Statement | When_Statement;
ReferenceStatement = Component_Reference ReferenceRhs;
ReferenceRhs = AssignmentRhs | Function_Call_Args; 
AssignmentRhs = ":=" Expression;
MultipleAssignment = "(" Output_Expression_List ")" ":=" Component_Reference Function_Call_Args;

If_Equation = "if" Expression "then" EquationPart* ElseIfEquation* [ElseEquation] "end" "if";
ElseIfEquation = "elseif" Expression "then" EquationPart*;
ElseEquation = "else" EquationPart*;

If_Statement = "if" Expression "then" StatementPart* ElseIfStatement* [ElseStatement] "end" "if";
ElseIfStatement = "elseif" Expression "then" StatementPart*;
ElseStatement = "else" StatementPart*;

For_Equation = "for" For_Indices "loop" EquationPart* "end" "for";

For_Statement = "for" For_Indices "loop" StatementPart* "end" "for";

For_Indices = For_Index+^",";

For_Index = Identifier [IndexSuffix];
IndexSuffix = "in" Expression;

While_Statement = "while" Expression "loop" StatementPart* "end" "while";

When_Equation = "when" Expression "then" EquationPart* ElseWhenEquation* "end" "when";
ElseWhenEquation = "elsewhen" Expression "then" EquationPart*; 

When_Statement = "when" Expression "then" StatementPart* ElseWhenStatement* "end" "when";
ElseWhenStatement = "elsewhen" Expression "then" StatementPart*;

Connect_Clause = "connect" "(" Component_Reference "," Component_Reference ")";

// Expressions

Expression = Simple_Expression | If_Expression;
If_Expression = "if" Expression "then" Expression ElseIfExpression* "else" Expression;
ElseIfExpression = "elseif" Expression "then" Expression;

Simple_Expression = Logical_Expression+^":"; 
//Simple_ExpressionSuffix = ":" Logical_Expression [Simple_ExpressionSuffix2];
//Simple_ExpressionSuffix2 = ":" Logical_Expression;

Logical_Expression = Logical_Term+^"or";

Logical_Term = Logical_Factor+^"and";

Logical_Factor = [Negation] Relation;
Negation = "not";

Relation = Arithmetic_Expression [RelationSuffix];
RelationSuffix = Rel_Op Arithmetic_Expression;

Rel_Op = "<" | "<=" | ">" | ">=" | "==" | "<>";

Arithmetic_Expression = [Add_Op] Term Arithmetic_Expression_Suffix*;
Arithmetic_Expression_Suffix = Add_Op Term;

Add_Op = "+" | "-" | ".+" | ".-";

Term = Factor TermSuffix*;
TermSuffix = Mul_Op Factor;

Mul_Op = "*" | "/" | ".*" | "./";

Factor = Primary [FactorSuffix];
FactorSuffix = Factor_Op Primary;

Factor_Op = "^" | ".^";

Primary = InitialPrimary | EndPrimary | DerPrimary | UnsignedNumber | String | FalsePrimary | TruePrimary | ComponentOrFunctionCallPrimary | OutListPrimary | ArrayConstructPrimary | ArrayConcatPrimary;
// that can't be as equation_section can be ended with "end" -> | EndPrimary;
FalsePrimary = "false";
TruePrimary = "true";
//looks like they forgot that completely in the spec *narf*
InitialPrimary = "initial" Function_Call_Args;
// this must be frickled later, or we need a LR(INFINITY) Parser ;)
ComponentOrFunctionCallPrimary = Component_Reference [Function_Call_Args];
OutListPrimary = "(" Output_Expression_List ")";
ArrayConcatPrimary = "[" Expression_List+^";" "]";
ArrayConstructPrimary = "{" [FunctionArgumentList] "}";
EndPrimary = "end";
//This one is because those morons seem to use der as keyword _and_ as an identifier :P
DerPrimary = "der" Function_Call_Args;

Name = Identifier+^".";

Component_Reference = ReferencePart+^"."; 
ReferencePart = Identifier [Array_Subscripts];

Function_Call_Args = "(" [FunctionArgumentList] ")";

//TODO: revamp that hole function argument stuff
FunctionArgumentList = Argument+^"," [ForSuffix];
Argument = [ArgumentName] Expression;
ForSuffix = "for" For_Indices;
ArgumentName = Identifier "=";

Output_Expression_List = [Expression] Output_Expression_List_Suffix*;
Output_Expression_List_Suffix = "," [Expression];

Expression_List = Expression+^",";

Array_Subscripts = "[" Subscript+^"," "]";

Subscript = SubscriptColon | Expression;
SubscriptColon = ":";

String_Comment = String+^"+";

Annotation = "annotation" Class_Modification;

// Terminal Wrapper
Identifier = "IDENT";
String = "STRING";
UnsignedNumber = "UNSIGNED_NUMBER";
